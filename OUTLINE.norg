* Overall structure
** Plugins
** Settings
** Mappings
  Should be defined in a common place, where providers (i.e. whatever the
  mappings bind to) defined in a `Settings` module.

  The mappings should then be defined as part of a hash, i.e.:
  @code lua
  {
    key = "<leader>",
    desc = "Leader Root",
    group = {
      key = "f",
      desc = "Finder",
      group = {
        key = "f",
        desc = "Find Files",
        run = config.fzf.find_files()
      }
    }
  }
  @end

  I also explored the posibility of a more "code-oriented approach", i.e.:

  @code lua
  Keys.n.x.buf
    .desc("grep string")
    .map("<leader>f", require("config").picker.grep)

  Keys.n
    .desc("Grep String")
    .map("<leader>f", require("config").picker.grep)

  Keys.n
    .desc("Tests")
    .group("<leader>t")(function(group)
      group
        .desc("Run nearest test")
        .map("n", config.test_runner.test_nearest)

      group.map("f", config.test_runner.test_file)

      -- This will force visual mode only for `test_selected`, which in turn
      -- will overwrite the groups mode.
      group.x.map("f", config.test_runner.test_selected)
  end
  )
  @end

  And while I like the "look" of that more, I fail to see how it actually
  provides any benefit over just using a hash.

  They both however allow me to group mappings in a much better way than to
  simply repeat `vim.keymap.set` everywhere, separating parts with comments,
  inevitably leading to disorganized code, propagating itself.

*** Dealing with plugins that map keys for you.
    Solution 1: Just don't use them?
    Solution 2: Write a wrapper provider for them which sets up the plugin
    based on the mappings provided.

    Just how a finder plugin might register itself and supply the functionality
    of "find-file", another plugin might register itself and supply the
    functionality of a textobject, which gets stored in a table in the wrapper,
    and once loaded, it uses those values.

    Or don't overcomplicate things: You can register something, but you could
    also just define keys which might directly be used by the mappings
    providers?

    Which would mean that e.g. `mini.ai` would reach directly into settings and
    grab values for that setting.

    i.e.

    @code lua
      local config = require("config")
      Keys.o
        .desc("Select Around Function")
        .map("if", config.text_objects.function.outer)
    @end

    This means that any mapping provider will have be told what they're bound
    to.
